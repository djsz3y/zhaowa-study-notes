# 设计模式 - CI/CD（上）

项目实践+Nginx+Docker-+CI/CD+Git

> 本节简介：  
> 整体的流程，从工程化、Docker 环境、CICD、GIT 方向上面，实际上在工程上面

> 项目应用的一些想法

## 打包工具

### Webpack or Vite

#### Webpack

1. 模块打包工具：Webpack 是一个模块打包工具，主要用于将多个 JavaScript 文件打包成一个或多个 bundle。它可以处理不仅仅是 JavaScript，还包括 CSS，图片等资源。

2. 构建过程：Webpack 通过读取一个入口文件（如`index.js`),分析这个文件和它的依赖，并将所有这些文件打包成一个（或多个）bundle。这个过程包括加载器(loader)和插件(plugin)来处理非 JavaScript 资源。

3. 开发服务器：Webpack 提供了一个可选的开发服务器(Webpack Dev Server),支持热模块替换(HMR)。

4. 适用范围：由于其广泛的配置选项和插件系统，Webpack 适用于大型复杂的前端项目。

5. 构建时间：对于大型项相，Webpack 的构建时间可能会比较长，因为它需要处理和打包项目中的每个文件。

#### Vite

1. 下一代前端构建工具：Vite 是一个更现代的开发环境，旨在提供更快的开发体验。它不是一个模块打包工具，而是一个利用原生 ES 模块(ESM)的开发服务器。

2. 构建过程：在开发模式下，Vite 为每个请求单独转换模块，而不是打包所有模块。这意味着它只会处理当前页面所需的模块，从而大大加快了重载和启动时间。

3. 生产构建：对于生产环境，Vite 使用 Rollup 进行打包。Rollup 是另一个现代的 JavaScript 打包器，专注于生成更小、更快的代码。

4. 快速冷启动：Vite 的一个显著特点是其快速的冷启动时间，因为它无需预打包。

5. 更少的配置：Vite 旨在提供开箱即用的体验，通常需要更少的配置。

---

#### Teacher 分析：

**用 Vite，基本 10 倍以上的快：**

- 解决环境变量的问题，Vite 配置更少，集成好了，只需使用 react 内嵌的包一个：`plugins: [react(),]`，这样配置一下就好，比如：

```bash
export default defineConfig(...{
  plugins: [react(),]
})
```

输入的入口：

- 把整个根目录作为 dev-server 的启动和打包目录的；
- 所以如果需要多入口的话，那就需要多个 html（如果项目需要十几个多入口，需要十几个项目 html）；

多入口场景：

- 比如：移动端 hybird 开发。

使用 SPA 和 MPA 的好处：

1. 搜索优化，可以引流。

2.

打包工具这里：

- 以后在实践当中，有新项目尽量使用 Vite 去靠：如果项目不大，改造成本不高，一些配置顺手就改了，在一些项目当中尽量多练练，多实践！借着公司给你的钱和时间去提升自己的能力，这不是最好的事儿吗，还显得你积极、进步。跟老大讲：最近咱 Vite 做的很好，咱家项目都是 Webpack 又慢打包又 xx，我自己加班主动申请我给你改造，你觉得老板不支持你吗，在你做完你基本工作的前提下。

- next 是一个开发环境。

**Vite 现在，基本已经成为主流：**

开发 dev 的体验：

- 至少从性能上、从实用上，从项目级别上已经成为咱们打包工具的新的助手了。webpack 逐渐被。。尤其是热更新。
- 比如现在改造的项目，使用 webpack 改一个 button 颜色，至少等到 5~10s 的 compile；如果项目够大够乱，俗话 SHI 山代码，可能十几秒刷出来，但 Vite 基本无感的，都喜欢双屏，基本这里一改几乎无感的。
- 要看项目，比如电商项目、视频、抖音项目，这边更改保存那边就出来了；

打包的体验：

- Vite 最后的 building 状态利用的 rollup；所以 webpack 和 rollup 在打包效率上讲，在同样的量级上面，并不一定快；但是打包我们是能接受的，开发体验更加重要，不知道该对还是改错了，习惯了就要等待 5s；

- Vite 基本团队上新项目应用了，无论 Vue 还是 React；

- 接小 SIHUO 重要的不是看钱，看的是能不能让你成长，用工作提升你自己的能力，是最最最好的方法。自主学习无目标性的学习少部分自律的人能做到，大部分人都需要打一鞭子走一步，就用 Vite 写。出海节项目；国内： 淘宝、一品威客、猪八戒、码站、码市、程序员客栈。价值&劳动不匹配；比如整个电商系统，下单、购物车、物流跟踪、付费，比如微信小程序登录、下单、浏览、搜索、加购、订单支付、物流跟踪、客服退单，开发周期加入 3 个月，许多人，多少你还有得赚，还能挣到钱？1000w 确实要做到抖音、淘宝、拼多多那个商城级别了；因为涉及很多子系统的建设，都需要很多人力的；加入 3 个月，工作日 60 天，6000 个人日，1500 起步，能力更高 2000、2500 都有可能；工程师+外包一部分，大概 9000w。
- Copilot：  
  -表结构输入给它，帮你做好智能化，会把代码吐给你；很多接口（比如搜索分页）都是可以复用的，表结构给他，固定格式，一堆搜索框还能表头排序；后端管理系统已经非常成熟了，前端可能还需要 AntD+逻辑修改一下；想生成 Java/Node.js/Python 等都可以；所有接口增删改查 put update 等都可以生成给你；  
  -而且数据监测、异常、返回都给你处理好了，你只要按照一定的格式输入进去，马上给你吐出来（Copilot&GPT4.0），与 VSCode 无缝集成；  
  -比如 Java 同学很多不写 Unit Test，你就可以用它写：直接项目目录输入给它（某项目目录之下，请帮我生成所有的 Unit Test），它就会帮你写，有没有发现现在白盒测试工程师现在越来越少了（写代码来测代码），有了 AI 后不需要了，这个工作岗位其实可能已经被 AI 干掉了；后面可能 Java、Node、前端写页面级别的基本上被干掉了；
- ChatGPT4.0 & Copilot 为什么排队交钱？代码模型大；全世界唯一一家开源代码管理的鼻祖，代码积累量大；大模型跟数据量非常正相关；跟人脸识别一样的道理，数据量非常庞大，全球 80 亿人口所有脸都收集过来，建立一个库，人脸识别是不是非常的准；**所以特征向量的提取和特征值的提取，与你本身的样本的多寡非常有关系的；**

- Vite 工具用起来：  
  -不难，比 Webpack 简单多的多；  
  -先上手，别先挖祖坟，别什么事想知道原理，这个事要到后面了解：深入浅出，学东西先用起来、配起来、熟悉起来，你再慢慢挖原理；  
  -Webpack 也不会坐以待毙，Rollup 也在用 rust 重写；

- 框架就是 React&Vue：  
  -哪个好？就是两种模式；  
  -Teacher 使用了 Vue 以后，多态 Store 数据管理让 Teacher 更舒服：不管哪个组件（子组件、父组件、X 组件）都是用一个 store，公共变量一起监听一起用，都可以享受其带来的变化，所以它跟 Emits 一个道理；  
  -React 也可以，是以 Provider 的形式做 Context，你要把你所需要共有共享的数据包起来，把组件包进去；但是如果没有关系的组件，没有包起来的组件——远亲组件就会很麻烦；  
  -本质上看你喜欢哪一个；这些组件，只是在做业务层的时候非常有用；有时，Vue 在一些功能上并不比 React 跑的慢，不一定哪个就是高手；开发感受上 Vue 写的更少；

- 比如：  
  1.React 的 4ass 内嵌、标签化的绑定（CSS 的计算、classname 的计算，第三方的组件 classname 的计算）等较多难；Vue 的 class 和:class 可以共存等很舒适；  
  2.Vue 的 Scope 的 style、DOM、Script 嵌在一起，React 的 JSX、CSS、JS 分开，基本多数都是文件夹套文件夹；项目结构上，Vue 的文件夹结构更加简单；Vue 项目当中，Vite 也注入了很多公共组件，比如说约定好的 Components 等等；  
  从这个角度讲，看每个人的感受；

- **大厂不看框架，熟悉一个即可；而是看你的底层功底：**  
  -你对业务、对代码的设计、代码模式比较清晰，而不是会用几个框架、过几年换新的；  
  -历史原因阿里使用 React，招 React 你就不投了？  
  -你要观测它框架的使用方式/设计模式，为什么做成这样（虽然没做过但是要代入进去），都是要有思考的；

- **代码注释在哪些地方要写：**  
  1.如果你在某个地方做了妥协、变更、提升，你一定要写下来，为什么要这么做？  
  2.只要你的代码不 ugly，基本 debug 都能看懂，是为了给你自己看，强制在这个过程中思考，哪怕写一句业务需要（尽管这么实现很糟糕），这个证明你 代码在向业务妥协（而不是你很蠢）；  
  3.比如我看到一段代码，没有任何解释（我觉得这段代码很蠢），找到改的人，就问你为什么写这么一行蠢的代码，然后你告诉我，你也想不起来了；那不好意思，我觉得你专业度不够；

- 这就是为什么很多大厂，很多人进不去的原因：  
  -不在于你的基础能力不够(我也说过，3/5 年以上你在写代码的层级上跟大厂没区别(不管专科/本科/985/211 都一样)，只是这个氛围&环境对人的要求&提升不一样了)，所以说你做的少、没做过、不经常做，你就不喜欢做；  
  -所以我们要求你这么去做，经常做；刚开始也会指导你，你写的多了，每一行代码你也就知道为什么这么去写；  
  -当你写代码会先思考为什么这么写的时候，你就成长了；而不是拿到需求 PRD 看看红的、蓝的，赶紧的先把东西码出来；

- 所以急的项目永远不利于成长：  
  -你没有时间思考，这就是对你职业最大的一个风险；  
  -不管做什么，一定要思考，有了思考你就会发现你的成长很快；  
  -哪怕你想一个问题你为什么要做它（哪怕是写项目需要、功能需要，你要把它写下来，证明你调研过、思考过、努力过），否则别人也不知道你在这方面做出了思考&努力，成没成长；

- 所以你在换的时候，看看 webpack 和 vite 的区别：  
  -甚至是同一个项目，你用 Vite 打包和 Webpack 打包，都有 Analyse 的插件；  
  -你可以看看打包的大小、打包的时间、打包的速度，相应的组件包加起来帮你分析，把每次的 log 都打出来，对比一下；  
  -同样打包 14 个，对比一下这两个数据，你做成一个表格，这就是你真正学到东西了；

- 那时有人问你：Vite 为什么比 Webpack 好？  
  -你就能从数据上告诉他我实际上跑过；  
  -那时你在自己看看文章、听别人讲、再看看源码：哦~原来他们是使用了这个原因而快，快在这儿；  
  -你要知道为什么而不是别人凭空说什么就是什么（那就是三人为虎了）；

---

再看打包：Npm or pnpm。

### Npm or pnpm

#### npm

- npm(Node Package Manager)是 Node.js 的默认包管理器，广泛用于 JavaScript 社区。
- 在 npm 中，当你安装一个包时，该包的所有依赖（以及依赖的依赖）都会被安装到顷目的 node_modules
  目录下。如果多个包依赖同一个包，该依赖可能会被多次安装在不同位置，导致 node_modules 目录非常庞大。
- npm 会尝试将依赖提升到尽可能高的层级，以避免重复，但这并不总能避免依赖的多次安装。

#### pnpm

- pnpm(Performant npm)是一个替代 npm 的包管理器，注重性能和效率。
- pnpm 使用了一种不同的方式来存储依赖。它在一个单独的全局位置维护所有下载的包，并在项目的 node_modules 目录中创建对这些包的硬链接。这种方法可以显著减少磁盘空间的使用，并加快安装速度。
- pnpm 保持了包的依赖结构，同时避免了重复下载相同的包，从而在保持 npm 兼容性的同时提高了效率。

#### 依赖安装位置

- 在 npm 中，如果一个包 A 依赖另一个包 B,而 B 又依赖另一个包 C,npm 会尝试将 C 安装在离根目录最近的位置。如果项目本身没有直接依赖 C,则 C 会被安装在 A 的 node_modules 目录下。如果项目本身也依赖 C,则 c 可能会被安装在项目顶层的 node_modules 中。
- pnpm 通过硬链接和符号链接的方式创建一个扁平化的 node modules 结构，从而避免了依赖重复，同时保持了依赖树的正确结构。

#### 总结

pnpm 是对 npm 的一个优化，主要在于更高效的依赖管理和磁盘空间的使用。它尝试解决 npm 中冗余依赖和大量磁盘使用的问题。在大型项目或多项目工作环境中，pnpm 的这些优势尤为明显。然而，npm 由于其作为 Node.js 默认包管理器的地位，仍然在 JavaScript 社区中占据着主导地位。

#### Teacher 分析

npm 和 yarn 组织方式差不多，就是在效率上有一些区别（命令行区别不大，但是组织方式不一致）

- A 引用 C, B 引用 C，npm 会把 C 安装两次，pnpm 只会安装一次；

- 不利于打包优化；C 只要打一次就够了；

pnpm 优点就是依赖扁平化：

举例：

- pnpm 有`pnpm-lock.yaml`：pnpm 工具帮你做的依赖包，也是根据`package.json`的`dependencies`和`devDependencies`来帮你打包的；

- 装完包你就一目了然了，可能有依赖（当你发现包下有循环依赖第三方包时，包上不会出现`node_modules`而是`loos`了）；比如有两个包都依赖了第三个包，就会放到`.pnpm`下，以`@*+*+*`的形式告诉你还有第三方依赖，在这里完全打平；
- 所以它抽取公共组件特别快，只需根据`pnpm-lock.yaml`，至少在包依赖上会快很多；还会节省空间，不需解析抽取公共包了，在这一步就做完了；还有其他工具就不深入探讨了；
- 只是一个包加载工具：就是项目初始化`pnpm install`，还有引入第三方新包的时候`pnpm add 一个包`；剩下该用 yarn 跑命令就用 yarn 他们命令行上没有本质区别，就是结构上按照自己的做的；

另外，我希望你们...

### 48:42

### 工程工具

CI/CD 具体内容看下面

**总结：没有最好的项目，持续优化才是王道。目前最佳实践 pnpm+vite 打包，建议使用 vue3（或者 svelte），利用 gitlab 的 CI/CD，主要是跟项目结合的比较好。Nginx 反向代理，如果有能力还是建议 nodejs 做渲染(ssr)和网关。业务层需要按照业务分好仓库，尽量不要把所有代码塞到一个项目。组件库的建设方案很多，<span style="color:red;">个人还是建议，直接使用 gitlab,方便又跟 CI/CD 无缝衔接。组件需要按需引入，打包速度和体积提升很大。</span>关于 CSS 多尺寸适配的问题，端尽量分开，利用 dns 重定向机制，pc 和移动，分开 2 个域名，独立代码建设。移动端使用 vw/vh 的解决方案，pc 端固定好骨架，尺寸依然使用 px。**

## Nginx 配置解读，最实用

1.`http`块

这是 Ngix 配置文件中最常见的块，用于定义所有与 HTTP 服务器相关的配置。

```nginx
http {
  # ...
}
```
