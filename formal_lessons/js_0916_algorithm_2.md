算法问题详解（2）0916——效率 & 策略

# 目录

数据结构与算法

一 前言

- 算法考察：算法考察开发人员对于代码/计算机语言熟悉&敏锐程度。

- **归纳**：从准备 -> 熟悉 -> 归纳，帮助更好的总结。

- **刷题**：代码的敏锐/熟练还是需要刷题。

<img src="./imgs/js_0909_algorithm_1/js_0909_algorithm_1.png" />

⼀、基础数据结构了解

    1.栈与队列
    2.数组和链表
    3.哈希表
    4.树结构

二 前言

⼆、数据结构分类实战

    5.栈的实现与应⽤
    6.单链表与双向链表
    7.树操作

三 & 四 前言

- 策略 -> 头绪 -> 找灵感

- 算法策略：四大策略类

- 回顾上节：  
  [1]算法在数据结构和需求之间，数据和需求的逻辑之间串通起了桥梁；  
  [2]算法最重要的一点是技巧和效率。

- 为什么需要这层，我们直接用数据结构做需求能做吗？  
  [1]绝大多数场景，日常工作中，很多时候我们屏蔽了这一层；我们直接拿数据结构做需求，数据结构不满足需求的，我们会跟后台/跟底层数据去沟通，把数据结构调整成当前需求所需要的。  
  [2]但是有些情况下，我们的确很需要在中间层做很多这样操作，算法就是这样很讲究策略和效率的。

- 那什么是策略？什么是效率？  
  [1]我们从后往前，先说效率。
  [2]再说策略。

<img src="./imgs/js_0916_algorithm_2/js_0916_algorithm_2_data-structures-and-algorithms.png" />

三、算法复杂度概念

    8.时间复杂度
    9.空间复杂度
    10.复杂度计算
    11.复杂度场景

四、具体算法技巧与概念

    12.分治法
    13.贪婪
    14.动态规划
    15.图

- 预习参考⽂档：  
  https://juejin.cn/post/6844904111092006925

五、⾯试技巧&学习总结

- 预习总结⽂档：  
  https://juejin.cn/post/6844903509351989261

- 推荐参考书籍：  
  《⼤话数据结构》、 《数据结构与算法分析》、《算法图解》、《剑指 offer》

# 三、算法复杂度概念（效率）

## 3.1 常见的时间复杂度

- `O(1)` 无循环
- `O(n)` 单次循环
- `O(logn)` 二分法
- `O(n*logn)` 单次循环 & 二分法
- `O(n^2)` 嵌套循环

<img src="./imgs/js_0916_algorithm_2/js_0916_algorithm_2_time-complexity.png" />

## 3.2 算法复杂度 - 时间复杂度、空间复杂度

> complexity.js

```js
// 算法复杂度 - 时间复杂度、空间复杂度
// 【时间复杂度】

// ------------------------------------------------------时间复杂度-窍门
// 时间复杂度 - O(n)
// 1. 找寻循环体，找循环次数最多的代码块
// 2. 最大值原则：当算法中出现多个循环，总复杂度等于最大的代码块的复杂度
// 3. 乘法原则：当算法中出现嵌套循环，总复杂度等于嵌套内外代码的复杂度的乘积

// ------------------------------------------------------total 线性阶 O(n)
function total(n) {
  let sum = 0 // t

  for (let i = 0; i < n; i++) {
    // nt = n次 * t时间
    sum += i // nt
  }

  return sum // t
}

total(10)
// total(n) 执行消耗了 t + nt + nt + t = 2(n + 1)t
// ------------------------------------------------------total2 O(n*n) 平方阶 O(n²)
function total2(n) {
  let sum = 0 // t

  for (let i = 0; i < n; i++) {
    // nt
    for (let j = 0; j < n; j++) {
      // n * n * t
      sum = sum + i + j // n * n * t
    }
  }

  return sum // t
}

total2(10)
// total2(n) 执行消耗了 t + nt + n*n*t + n*n*t + t = (2n*n + n + 2)t
// n => ∞ : O(n) O(n*n)
// ------------------------------------------------------1 - 常数阶 0(1)
// 1 - 常数阶 0(1)
const sum_plus = function () {
  let i = 1 // t
  let j = 2 // t
  ++i // t
  j++ // t
  return i + j // t
}

sum_plus()
// sum_plus 执行消耗了 t + t + t + t + t = 5t
//    （如果传入参数n）
//     n => ∞，5可以忽略就是1。
// 0(1)

// ------------------------------------------------------2 - 线性阶 O(n)
// 2 - 线性阶 O(n)
function total_2(n) {
  let sum = 0 // t

  for (let i = 0; i < n; i++) {
    // nt
    sum += i // nt
  }

  for (let j = 0; j < 3; j++) {
    // 2t
    sum += j // 2t
  }

  return sum // t
}
total_2() // n > 2
// total_2() 执行消耗了 t + nt + nt + 2t + 2t + t = (2n+4+2)t = 2(n+3)t
//    n => ∞，常数也被忽略了。
// O(n)

// ------------------------------------------------------3 - 对数阶 O(logN)
// 3 - 对数阶 O(logN)
const foo3 = function (n) {
  let i = 1
  while (i < n) {
    i = i * 2
  }
}
// 分析1：
// 第一次，i=2=2^1
// 第二次，i=4=2^2
// 第三次，i=8=2^3
// 第 x-1 次，i= 2^(x-1)
// 第 x 次，i = 2ˣ
// 因为 i < n，
// 那么当 i >= n 时跳出循环，所以第 x 次执行完，跳出循环；
// 此时 2ˣ >= n，
// 所以 x = log(2)(n)
// 所以执行消耗了 t + xt + xt = 1 + 2 * log(2)(n) * t

// 分析2：
// i 等比变化 2ⁿ 次 => 2ˣ = n => x = log2ⁿ => 循环log2ⁿ 次
// 所以是 O(logN)

// -----------------------------------------------3.2 - 线性对数阶 O(nlogN)
// 3.2 - 线性对数阶 O(nlogN)
// O(logN) 变形：
//    => O(nlogN)
//    y = 2ˣ
//    x = log2y
const foo3 = function (n) {
  let i = 1
  for (let i = 0; i < n; i++) {
    // nt
    while (i < n) {
      // (n * logN)t
      i = i * 2
    }
  }
}
// -----------------------------------------------4 - 其他
// 指数阶
//    立方阶
//    k次方阶
//    无限的嵌套循环

// 【空间复杂度】
// ------------------------------------------------------空间复杂度-窍门
// 和时间复杂度的 区别：
//               关注有没有增加新的空间占有

// ------------------------------------1.常量
const constant = function (n) {
  let j = 0
  for (let i = 0; i < n; i++) {
    j++
  }
}
// j只是值，并没有开辟新的空间
// O{1}

// ------------------------------------2.线性增长
const line = function (n) {
  let j = []
  for (let i = 0; i < n; i++) {
    j.push(i)
  }
}
// j是数组，j.push(i)堆里开辟了新空间
// O{n}

// ------------------------------------3.同理
// 相应的，
// 如果是 while循环的二分查找里push，
//                  就是 log 增长，就是 O{logN}
// 如果是 嵌套循环里push，
//        就是 n平方的增长，就是 O{n^2}

// 增长
```

# 四. 具体算法技巧与概念（策略）

## 4.1 分治

> strategy/D&C.js

```js
// 分而治之 => 分治法
// 云 => yun => y => 788 ~ 888 => 800 - yan => 800 ~ 888 => 850 - yuan => 850 ~ 888……

// 工作原理：
// 1. 找出基线条件
// 2. 不断将问题进行分解 —— 和基线保持一致
// 3. 直到问题拆解的遗留项和基线条件本身一致 （查找）
// 3’. 细化（遍历）

// 面试题：快排 / 快速排序
// 1. 数据结构：数组来进行排序和待排序
// 2. 运行方式：递归（反复执行相同操作，传入值不同，反复递归相同函数） - 算法主体结构
// 3. 确定输入输出 - 确定流程

// 快速排序 - 用分治法的思路：
const quickSort = function (arr) {
  let xxx = []
  // 1. 对当前数组做基线条件定义 => 在数组中找到一个值作为基线
  // 2. 根据基线条件对主体数组进行拆分 => 分别对前后两项进行基线条件定义
  // 3. 再回到第一步
  // 4. 退出条件 - 只剩下基线本身

  // 4. 只剩下基线本身
  if (arr.length < 2) {
    return arr
  }

  // 1. 计算基线
  let pivotIndex = Math.floor(arr.length / 2)
  let pivot = arr.splice(pivotIndex, 1)[0]

  let left = []
  let right = []

  // 2. 拆分
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }

  // 3. 回到第一步 - 递归
  return quickSort(left).concat([pivot], quickSort(right))
}
// 最好：O(nlogn)，最坏：O(n^2)
// 快排复杂度 <= 冒泡复杂度
```

## 4.2 贪婪/贪心

获取利益最大化，始终查找最大项目，尽可能快速满足需求

> strategy/greedy.js

```js
// 贪婪 获取利益最大化，始终查找最大项目，尽可能快速满足需求

// 面试题
// 给定一个数组nums，找到一个具有最大和的连续子数组（子数组必须最少包含一个元素），返回其最大和
// [1, 2, 3, 5, -9, 2, 10, 22, -30] => 36
// （[1, 2, 3, 5, -9, 2, 10, 22]）

const maxSubArray = function (nums) {
  // 1. 数据结构：数组。栈？不。 => 确定数据结构为数组
  // 2. 遍历 => sum - 当前子序列的和；ans - 表示结果

  // 3. 如果sum > 0，则说明sum对结果有整体增益效果 => sum保留并且加上当前遍历数字
  // 4. 如果sum<=0，无增益效果，舍弃 => sum 则直接更新为当前遍历的数字即可
  // 5. 每次都比较sum和ans的大小，将最大值给到ans

  let ans = nums[0]
  let sum = 0

  for (const num of nums) {
    if (sum > 0) {
      sum += num
    } else {
      sum = num
    }
    ans = Math.max(ans, sum) // 始终取最大值
  }
  return ans
}
```

## 4.3 动态规划

1. 走一步看一步
2. 可划分职责领域，下一步规划
3. 斐波那契数列 or 杨辉三角 => 通项公式
   前后两项相关（第一项=0，第二项=1，之后每一项都等于前两项之和）-> 走一步看一步。

最简单方式用递归实现，但是如何用两种方式（递归、遍历方式）实现动态规划？面试官想看到的遍历方式。

如何用**遍历方式**解决**动态规划**？如何用**遍历方式**解决**通项公式**问题？

> strategy/dp.js

```js
// 动态规划 - 走一步看一步
// 更加灵活 => 可划分职责领域，下一步规划

// 斐波那契数列 or 杨辉三角 => 通项公式
// F(0) = 0, F(1) = 1
// F(n) = F(n - 1) + F(n - 2), 其中 n > 1

// ------------------------------------遍历
const fib = function (n) {
  // 1. 非通项公式 区域外的东西/规划外的东西，列出来；
  if (n < 2) {
    return n
  }
  // 2. 从第二项开始，每一项都等于前两项之和；
  // 所以，只需要记录：前一项、后一项，以及最后的结果
  let pre = 0, // 前一项
    next = 0, // 后一项
    result = 1 // 最后结果

  // 3. 从 2 开始遍历
  //    用遍历，将每一步的通项公式，转换成实际运行的结果，每一步 next、pre 不同，所以在每一步都要走一步看一步。
  for (let i = 2; i <= n; i++) {
    // 走一步看一步
    pre = next // 后一项往前移
    next = result // 已经求和完成的 当作统一的一项来处理。
    result = pre + next
  }

  // 4. 直接 result
  return result
}
/**
 * !经测试，发现要注意：for 循环的 <=：`i <= n`。
 * f(2) = f(1) + f(0) = 1
 * f(3) = f(2) + f(1) = 1 + 1 = 2
 * f(4) = f(3) + f(2) = 2 + 1 = 3
 */

// ------------------------------------递归
// ……
// 一共三行。
function fibonacciMemoization(n) {
  if (n < 2) {
    return n
  }
  const memo = [0, 1]
  const fibonacciMem = (num) => {
    if (memo[num] != null) {
      return memo[num]
    }
    return (memo[num] = fibonacciMem(num - 1) + fibonacciMem(num - 2))
  }
  return fibonacciMem(n)
}
// f5=f4+f3=[(f1+f0+f1)+(f1+f0)] + (f1+f0+f1) = 5
// f4=f3+f2=(f1+f0+f1)+(f1+f0)
// f3=f2+f1=f1+f0+f1
// f2=f1+f0
// f1=1
// f0=0
```

# 五、⾯试技巧&学习总结（面试官问）

1. 算法中执行了多少遍，算法复杂度是多少？
2. 有没有办法减少次数并不影响输出？变相问你如何优化当前算法。
