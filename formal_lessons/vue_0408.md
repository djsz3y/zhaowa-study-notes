## vue 基础用法

### 理论开始

#### 面试题 1：简单聊聊对于 mvvm 的了解

a. 语义化模板 => 可读性
b. MVC - model view controller => （对整体）设计认知
c. MVVM - Model-View-ViewModel（状态-视图-数据视图绑定层。对主流框架有使用经验和了解）
i. 数据回绑定在 viewModel 层并且会直接驱动数据到页面的渲染 => 自动 trigger（第一层自动化）
ii. （数据到视图）视图变化时，同时也会通知到 viewModel 层

### 写法

#### vue 是如何利用 mvvm 思想进行开发的？

数据的双向绑定（如何利用 mvvm，特点）
a. 利用花括号 => 若干正则进行 template pass（正则条件判断）
b. 通过视图绑定事件 => 依赖收集、trigger

#### 生命周期

##### 面试题 2：vue 生命周期？

beforeCreate => created => beforeMount => mounted
=> beforeUpdate => updated
=> beforeDestory => destroyed
bC（bC 区别）:new Vue() - 初始化类、挂载属性
c: data, props, methods, computed -> 数据操作和属性合并 => 不涉及到 vdom 和 dom 的方法处理。

=> setup 阶段

bM：vDom(完整获取) - 描述 dom 的虚拟节点，数据操作（可以做几乎所有的） => 不可以涉及 dom 操作
m: Dom - 任何操作

(图表绘制、低代码、装饰器用到)
bU：（实例更新、vnode 更新）vDom 更新了，dom 没更新，没有触发 render 实例 -获取到的数据-新，dom 不新
u：dom 更新了
=> 谨慎在 bU、u 里写对 dom 的操作（死循环）

bD: vm 销毁前
d: 实例销毁后

=> unmount

后面通读源码

#### 面试题：vue 中有哪些实现定向监听的方法

##### computed 和 watch 异同

相同点：

1. 基于 vue 的依赖收集机制 => a: {b:1} => {{ a }} - {{ b }}
   watch a b 变化
   computed c=a+b,
2. 都是被依赖的变化触发，进行改变进而进行处理计算  
   watch b 变化，a 逻辑运行；  
   computed a 依赖于 b 变化。  
   都是计算。

不同点
（吸顶操作，首先入参、出参）

1. 入和出  
   computed：多入单出 - 多个值变化，组成导致一个值的变化  
   watch：单入多出 - 单个值变化，进而影响一系列状态的变更

2. 性能
   computed: 自动 diff 依赖，如果依赖没有变化，优先从缓存中读取当前计算值。（关注值本身）  
   watch: 无论监听值发生变化与否，都会执行回调（关注逻辑，值变了，逻辑没变就可以）  
   （压力面，知识储备的自信程度）

3. 写法
   computed: 必须有 return  
   watch：比一定

4. 时机上
   computed: 从首次生成赋值
   watch: 首次是不运行的，immediate: true -> 初始化时就跑

#### 条件

##### v-if & v-show & v-else & v-else-if

v-if 无 dom，不会渲染实际节点以及子节点
依赖倒置，父元素的不要在子元素里计算：值拉出来，不属于父元素不属于子元素，一部分给父，一部分给子元素，将来去掉子元素，可维护性高。
v-show 有 dom，不展示，不占据位置

#### 循环

##### 面试题：v-for 和 v-if 优先级的问题？

vue2.x 中，v-for 会优先响应
vue3.x 中，v-if 优先

##### 面试题： key 的作用

1. 模板编译原理 —— template => dom  
   template => 正则匹配语法 - 生成了 AST：静态+动态 => 转化为节点，并且整体生成可执行方法 => render() => 生成 dom
2. dom diff
   1 2 3 4 5 6  
    6 5 7 3 2 1  
   层级：只考虑单层复用，错层遍历实现  
   顺序：双向指针，首尾向中间移动（首尾 移动、新增、删除）  
   操作：移动、新增、删除  
   => key - 快速识别节点

3. （节点没有实时刷新）key - 尽量可复用节点标识
   常见问题：index 做 key，随机数做 key（失去了 dom diff 的一次性能优化）

- 哦哦哦，我看看下课看看我用的 forceUpdate 是什么情况

#### 指令

##### 默认指令

v-once - 只渲染一次  
v-text - 渲染字符串  
v-html - 渲染 html  
v-bind - 绑定赋值  
v-on - 监听  
v-model - 双向绑定 => :value + @input

```js
  model: {
    prop: 'selected',
    event: 'change'
  }
```

##### 自定义指令

```js
  directives: {
    yunyin: {
      update: function() {
        // ...
      }
    }
  }
  <div v-yunyin></div>
```

#### 事件

##### v-on @

##### 修饰符

.stop .prevent .capture .self .once  
按钮修饰符

## 举例

> HelloWorld.vue

```html
<template>
  // 数据类型 // 面试题 // 1.数值转换类类型
  <h1>number + 1 : {{ number + 1}}</h1>
  数字类型计算
  <h1>{{ msg.slice(0, -1)}}</h1>
  字符串操作
  <h1>{{ number.toFixed(2) }}</h1>
  浮点
  <h1>{{ parseInt(number, 10) }}</h1>
  整形计算
  <!-- 上面4个都可以 -->

  // 2.回调本地函数的方式
  <h1>{{ calcNumber(number) }}</h1>

  // 3.先执行语句拿到值，再放模板里
  <h1>100 > 99 {{ 100 > 99 ? '对':'错'}}</h1>

  <h1>{{ addMsg }}</h1>
</template>
<script>
  import son from './son.vue'


  data(){
    return {
      msg:'welcome to Your Vue.js App',
      number: 100,
      number2: 0
    }
  },
  computed: {
    addMsg() {
      return this.msg + this.number
    }
  }
  methods: {
    calcNumber(number){
      return num + 2
    }
  },
  watch: {
    number() {
      this.number2++
    }
  },
  mounted() {
    this.number2 = 1 // 生命周期的变化
  }
</script>
```

> son.vue

```html
<template>
  <div>son</div>
</template>
<script>
  export default {
    name: 'son'
  }
</script>
```

> HelloWorld.vue

```html
<template> </template>
<script setup>
  // 解耦
  import {
    reactive, computed,watch, onMounted
  } from 'vue'
  const msg = 'welcome to Your Vue.js App'
  const state = reactive({
    number: 100,
    number2: 0
  })
  const addMsg = computed(() => msg + state.number)
  const calcNumber = num => num+2

  watch(
    () => state.number,
    (number, preNumber) => {
      state.number2++
    }
  )
  onMounted(() = >{
    state.number2 = 1
  })
</script>
```

1. 初始化  
   watch  
   c = a+b => c immdiate => 合并  
   computed

2. button -单个 tick  
   c = a+b  
   computed => 执行一次

3. 跨 tick  
   template => {{ }}

0409 开头补充：

4. computed & watch

```js
computed: {
  c() {
    d
    return a + b
  }
},
watch: {
  a() {
    // to do
  }
}
```

5. 单 tick diff
